/*
   Author: Yogesh Nagarkar
   Copyright: YesHog (www.yeshog.com)
*/
#include "bignum.h"

int test_modexp(void);
int test_div(void);
int test_div_smallbuf_1(void);
int test_mod_inv_basic(void);
int test_mul(void);
int test_div_small_quo1(void);
int test_div_small_quo2(void);
int test_div_small_quo3(void);
int test_div_small_quo4(void);
int test_div_small_quo5(void);
RESULT test_mul_helper( Integer, Integer, Integer);
int test_mod_barrett(void);
int test_top_word(void);
int test_div_small_quo6(void);
int test_mul8(void);
int test_sqr(void);
int test_cmp_(void);
BYTE bitOffset_func(BYTE );
int test_bitOffset(void);
int test_modinv_ctz(void);
int test_sub(void);
#define QUOTIENT_INCORRECT -1
#define REM_INCORRECT -2

int main (void)
{
    if( test_modinv_ctz() < 0 )
    {
        printf( "test modinv base case [failed] \n" );
    }
    /*
    if( test_sub() < 0 )
    {
        printf( "test modinv base case [failed] \n" );
    }
    if( test_mod_inv_basic() < 0 )
    {
        printf( "test modinv base case [failed] \n" );
    }
    test_top_word();
    if( test_sqr() != OK )
    {
        return 1;
    }
    if( test_cmp_() < 0 )
    {
        printf( "test cmp \n" );
    }
    if( test_bitOffset() < 0 )
    {
    	printf( "test bitOffset failed \n" );
    }
    if( test_mul8() < 0 )
    {
        return 1;
    }
    if( test_mul() < 0 )
    {
        return 1;
    }
    if( test_div() < 0 )
    {
        return 1;
    }
    if( test_div_smallbuf_1() < 0 )
    {
        printf(  "test_div_smallbuf_1 [failed]\n" );
    }
    if( test_modexp() < 0 )
    {
        printf( "test_modexp [failed]\n");
    }
    if( test_mod_barrett() < 0 )
    {
        printf( "mod barrett failed \n" );
    }
    */
    return 0;
}

int test_modinv_ctz(void)
{
    printf( "modinv_ctz\n" );
    printf( "modinv_ctz(%02X) = [%d] ", 0xFF, byte_ctz(0xFF) );
    printf( "modinv_ctz(%02X) = [%d] ", 0xF2, byte_ctz(0xF2) );
    printf( "modinv_ctz(%02X) = [%d] ", 0xF4, byte_ctz(0xF4) );
    printf( "modinv_ctz(%02X) = [%d] ", 0xF8, byte_ctz(0xF8) );
    printf( "modinv_ctz(%02X) = [%d] ", 0xFA, byte_ctz(0xFA) );
    printf( "modinv_ctz(%02X) = [%d] ", 0xF0, byte_ctz(0xF0) );
    printf( "modinv_ctz(%02X) = [%d] ", 0x20, byte_ctz(0x20) );
    printf( "modinv_ctz(%02X) = [%d] ", 0x40, byte_ctz(0x40) );
    printf( "modinv_ctz(%02X) = [%d] ", 0x80, byte_ctz(0x80) );
    printf( "modinv_ctz(%02X) = [%d] ", 0x00, byte_ctz(0x00) );
    printf( " end modinv_ctz\n" );
    BYTE _s[] = {0xFD, 0x62, 0x13, 0x0F, 0xA5, 0x66, 0x0F, 0x97};
    BYTE _n[] = {0xFE, 0xAA, 0x9A, 0x5D, 0x78, 0x00, 0x50, 0x2B};
    dint( n, _n, sizeof( _n ) );
    dint( s, _s, sizeof( _s ) );

    mint( s1, 2*sizeof( _s ) );
    printf( "\n " );
    printInteger( s );
    printf( " " );
    printInteger( n );
    printf( "\n" );
    modinv( s, n, s1 );
    printf( "\n sInv \n " );
    printInteger( s1 );
    printf( " = " );

    printf( HEXCALC_OPEN "mod(" );
    printInteger( s1 );
    printf( "*" );
    printInteger( s );
    printf( "," );
    printInteger( n );
    printf( ")" HEXCALC_CLOSE " = 1\n" );

no_mem_:
    flint( n );
    flint( s );
    flint( s1 );
    return 0;
    return OK;
}
int test_sub(void)
{
    SSHORT _r_ = 0;
    BYTE a [] =
    {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x51
    };
    BYTE b [] =
    {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0xA1
    };
    lint( A, a );
    lint( B, b );
    _r_ =  sub_( A->buf, A->size, B->buf, B->size, A->buf, A->size );
    setOffset(A);
    printInteger( A );
    printf("\n");
    return _r_;
}

int test_cmp_(void)
{
    SSHORT _r_ = 0;
    BYTE a [] =
    {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9
    };
    BYTE b [] =
    {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9
    };
    BYTE c [] =
    {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC8
    };
    BYTE d [] =
    {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xCA
    };
    BYTE e [] =
    {
            0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xCA
    };
    BYTE f [] =
    {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9,
            00
    };
    lint( A, a );
    lint( B, b );
    lint( C, c );
    lint( D, d );
    lint( E, e );
    lint( F, f );
    _r_ = cmp_(A, B, _r_ );
    printf( "cmp_( A, B ) = [%d] ", _r_ );
    _r_ = cmp_(A, C, _r_ );
    printf( "cmp_( A, C ) = [%d] ", _r_ );
    _r_ = cmp_(A, D, _r_ );
    printf( "cmp_( A, D ) = [%d] ", _r_ );
    _r_ = cmp_(A, E, _r_ );
    printf( "cmp_( A, E ) = [%d] ", _r_ );
    _r_ = cmp_(A, F, _r_ );
    printf( "cmp_( A, F ) = [%d] ", _r_ );
    return OK;
}
#define test_bitoff( x ) printf( "bitOffset(%02X) = [%d] [%d] [%s]\n", \
                                   x, bitOffset(x), bitOffset_func(x), \
                       (bitOffset(x)-bitOffset_func(x))? "FAIL":"OK" )
/* deprecated */
BYTE bitOffset_func(BYTE x)
{
    if ( x == 0 ) return 0xFF;

    BYTE t[] = {
               0x80, 0x40, 0x20, 0x10,
               0x08, 0x04, 0x02, 0x01
               };
    BYTE j = 0;
    for(; j < sizeof(t) ; j++)
    {
        if( t[j] & x ) break;
    }
    return j;
}
int test_bitOffset(void)
{
    test_bitoff( 0xEF );
    test_bitoff( 0x60 );
    test_bitoff( 0x4F );
    test_bitoff( 0x3C );
    test_bitoff( 0x2A );
    test_bitoff( 0x10 );
    test_bitoff( 0x0A );
    test_bitoff( 0x07 );
    test_bitoff( 0x05 );
    test_bitoff( 0x04 );
    test_bitoff( 0x03 );
    test_bitoff( 0x02 );
    test_bitoff( 0x01 );
    test_bitoff( 0xFF );
    return OK;
}
int test_sqr(void)
{
    BYTE x5 [] =
    {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85,
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2,
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32,
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9
    };
    BYTE r[64];
    memset(r, 0, sizeof r);
    sqr(x5, sizeof x5, r, sizeof r);
    printf( HEXCALC_OPEN );
    printBuf( x5, sizeof x5 );
    printf( "*" );
    printBuf( x5, sizeof x5 );
    printf( HEXCALC_CLOSE "=" );
    printBuf( r, sizeof r );
    printf( "\n" );
    return OK;
}
int test_mul8(void)
{
    BYTE a[] = { 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
    BYTE b[] = { 0x02, 0x03, 0x04, 0xFF, 0xFE };
    BYTE R[ 12 ];
    memset( R, 0, sizeof R );
    /*
    mul8_( a, sizeof a, b, sizeof b, R, sizeof R );
    */
    mul_( a, sizeof a, b, sizeof b, R, sizeof R );
    printBuf( a, sizeof a );
    printf( "*" );
    printBuf( b, sizeof b );
    printf( " = ");
    printBuf( R, sizeof R );
    printf( "\n" );
    return OK;
}
int test_top_word(void)
{
    BYTE a[] = { 6, 7, 8, 9 };
    BYTE b[] = { 1, 0, 0, 0 };
    lint( A, a );
    lint( B, b );
    WORD m = getTopWordSafe( A, 4 );
    WORD n = getTopWordSafe( B, 3 );
    printf( "%X, %X\n",   (SHORT)((getTopWordSafe( A, 4 ))/(getTopWordSafe( B, 3 ))), 
                        (SHORT) (m/n) );
    return OK;
}

RESULT test_mul_helper( Integer X, Integer Y, Integer R )
{
    RESULT r = OK;
    printf( HEXCALC_OPEN );
    printInteger( X );
    printf( "*" );
    printInteger( Y );
    printf( HEXCALC_CLOSE " = " );
    r = mul( X, Y, R );
    printInteger( R );
    printf( "\n" );
    return r;
}

#define mul_template( x, y, r, n )    \
    lint( X##n, x );                  \
    lint( Y##n, y );                  \
    BYTE r##n[sizeof(x) + sizeof(y)]; \
    lint( R##n, r##n )

int test_mul(void)
{
    RESULT res;
    BYTE x1[] = { 0x01, 0x01 };
    BYTE y1[] = { 0x01, 0x01 };
    mul_template( x1, y1, r, 1 );
    res = test_mul_helper( X1, Y1, R1 );
    BYTE x2[] = { 0xFF, 0xFF, 0xFF };
    BYTE y2[] = { 0xFF, 0xFF };
    mul_template( x2, y2, r, 2 );
    res = test_mul_helper( X2, Y2, R2 );
    BYTE x3[] = { 0xFF, 0xFF };
    BYTE y3[] = { 0xFF, 0xFF, 0xFF };
    mul_template( x3, y3, r, 3 );
    res = test_mul_helper( X3, Y3, R3 );
    BYTE x4[] = { 0xFF, 0xFF, 0xFF, 0xFF };
    BYTE y4[] = { 0xFF, 0xFF, 0xFF, 0xFF };
    mul_template( x4, y4, r, 4 );
    res = test_mul_helper( X4, Y4, R4 );
    BYTE x5 [] = {
            0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85, 
            0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2, 
            0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32, 
            0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9, 
            0x76, 0x3F, 0xE3, 0x9C, 0xB6, 0x37, 0x79, 0x03, 
            0xB9, 0xAB, 0x69, 0x8D, 0x07, 0x25, 0xB6, 0x19, 
            0x67, 0xE4, 0xB0, 0x1B, 0x18, 0x73, 0x61, 0x4A, 
            0xE8, 0x7E, 0xCD, 0xD3, 0x2F, 0x64, 0xE3, 0xA6, 
            0x7C, 0x0C, 0xFA, 0x17, 0x80, 0xA3, 0x0D, 0x47, 
            0x89, 0x4F, 0x51, 0x71, 0x2F, 0xEE, 0xFC, 0x3F, 
            0xF9, 0xB8, 0x16, 0x80, 0x87, 0x89, 0x93, 0x25, 
            0x20, 0x9A, 0x43, 0x82, 0x69, 0x24, 0x76, 0x28, 
            0x59, 0x35, 0xA1, 0x1D, 0xC0, 0x7F, 0x83, 0x06, 
            0x64, 0x16, 0x20, 0x2C, 0xD3, 0x49, 0xA4, 0x85, 
            0xB4, 0xC0, 0x61, 0x7F, 0x51, 0x08, 0xF8, 0x68, 
            0x15, 0x91, 0x80, 0xCB, 0xA5, 0xD5, 0xEE, 0x3B, 
            0x3A, 0xF4, 0x84, 0x04, 0x5E, 0x60, 0x59, 0xA7, 
            0x8C, 0x34, 0x72, 0xEE, 0xB8, 0x78, 0xC5, 0xD1, 
            0x3B, 0x12, 0x4A, 0x6F, 0x7E, 0x65, 0x27, 0xB9, 
            0xA4, 0x55, 0xC5, 0xB9, 0x6F, 0x43, 0xA4, 0xC5, 
            0x1D, 0x2C, 0x99, 0xC0, 0x52, 0xA4, 0x78, 0x4C, 
            0x15, 0xB3, 0x40, 0x98, 0x08, 0x6B, 0x43, 0xC6, 
            0x01, 0xB0, 0x7A, 0x7B, 0xF5, 0x6B, 0x1C, 0x22, 
            0x3F, 0xCB, 0xEF, 0xFF, 0xA8, 0xD0, 0x3A, 0x4B, 
            0x76, 0x15, 0x9E, 0xD2, 0xD1, 0xC6, 0x2E, 0xE3, 
            0xDB, 0x57, 0x1B, 0x32, 0xA2, 0xB8, 0x6F, 0xE8, 
            0x86, 0xA6, 0x3F, 0x70, 0xAB, 0xE5, 0x70, 0x92, 
            0xAB, 0x44, 0x1E, 0x40, 0x50, 0xFB, 0x9C, 0xA3, 
            0x62, 0xE4, 0x6C, 0x6E, 0xA0, 0xC8, 0xDE, 0xE2, 
            0x80, 0x42, 0xFA, 0xE9, 0x2F, 0xE8, 0xCE, 0x32, 
            0x04, 0x8F, 0x7C, 0x8D, 0xB7, 0x1C, 0xA3, 0x35, 
            0x3C, 0x15, 0xDD, 0x9E, 0xC3, 0xAE, 0x97, 0xA5
    };
    BYTE y5[] = { 0x00, 0xEA };
    bint( X5, sizeof(x5), x5, sizeof(x5) );
    bint( Y5, sizeof(y5), y5, sizeof(y5) );
    BYTE z5[ 520 ];
    memset( z5, 0 , sizeof(z5 ) );
    mul_( x5, sizeof( x5 ), y5, sizeof( y5 ), z5, sizeof(z5) );
    bint( z, sizeof(z5), z5, sizeof(z5) );
    printf( "\nbigbuf * short, " HEXCALC_OPEN );
    printInteger( X5 );
    printf( "*" );
    printInteger( Y5 );
    printf( HEXCALC_CLOSE " = " );
    printInteger( z );
    printf( "\n" );
    flint( X5 );
    flint( Y5 );
    flint( z );
    return res;
}

int test_div()
{
    BYTE sig[] =
    {
                0xA4, 0xF3, 0x25, 0xCC, 0xD1, 0xD4, 0x91, 0x83, 
                0x22, 0xD0, 0xCC, 0x32, 0xAB, 0x9B, 0x96, 0x4E, 
                0x34, 0x91, 0x54, 0x20, 0x25, 0x34, 0x61, 0x5F, 
                0x2A, 0x02, 0x15, 0xE1, 0x8B, 0xAA, 0xFF, 0x7D, 
                0x64, 0x51, 0xCF, 0x0A, 0xFF, 0xBC, 0x7D, 0xD8, 
                0x21, 0x6A, 0x78, 0xCB, 0x2F, 0x51, 0x6F, 0xF8, 
                0x42, 0x1D, 0x33, 0xBD, 0xEB, 0xB5, 0x7B, 0x94, 
                0xC3, 0xC3, 0xA9, 0xA0, 0x2D, 0xDF, 0xD1, 0x29, 
                0x1F, 0x1D, 0xFE, 0x8F, 0x3F, 0xBB, 0xA8, 0x45, 
                0x2A, 0x7F, 0xD1, 0x6E, 0x55, 0x24, 0xE2, 0xBB, 
                0x02, 0xFB, 0x31, 0x3F, 0xBE, 0xE8, 0xBC, 0xEC, 
                0x40, 0x2B, 0xF8, 0x01, 0xD4, 0x56, 0x38, 0xE4, 
                0xCA, 0x44, 0x82, 0xB5, 0x61, 0x20, 0x21, 0x67, 
                0x65, 0xF6, 0xF0, 0x0B, 0xE7, 0x34, 0xF8, 0xA5, 
                0xC2, 0x9C, 0xA3, 0x5C, 0x40, 0x1F, 0x85, 0x93, 
                0x95, 0x06, 0xDE, 0x4F, 0xD4, 0x27, 0xA9, 0xB6, 
                0xA5, 0xFC, 0x16, 0xCD, 0x73, 0x31, 0x3F, 0xB8, 
                0x65, 0x27, 0xCF, 0xD4, 0x53, 0x1A, 0xF0, 0xAC, 
                0x6E, 0x9F, 0x4F, 0x05, 0x0C, 0x03, 0x81, 0xA7, 
                0x84, 0x29, 0xC4, 0x5A, 0xBD, 0x64, 0x57, 0x72, 
                0xAD, 0x3B, 0xCF, 0x37, 0x18, 0xA6, 0x98, 0xC6, 
                0xAD, 0x06, 0xB4, 0xDC, 0x08, 0xA3, 0x04, 0xD5, 
                0x29, 0xA4, 0x96, 0x9A, 0x12, 0x67, 0x4A, 0x8C, 
                0x60, 0x45, 0x9D, 0xF1, 0x23, 0x9A, 0xB0, 0x00, 
                0x9C, 0x68, 0xB5, 0x98, 0x50, 0xD3, 0xEF, 0x8E, 
                0x2E, 0x92, 0x65, 0xB1, 0x48, 0x3E, 0x21, 0xBE, 
                0x15, 0x30, 0x2A, 0x0D, 0xB5, 0x0C, 0xA3, 0x6B, 
                0x3F, 0xAE, 0x7F, 0x57, 0xF5, 0x1F, 0x96, 0x7C, 
                0xDF, 0x6F, 0xDD, 0x82, 0x30, 0x2C, 0x65, 0x1B, 
                0x40, 0x4A, 0xCD, 0x68, 0xB9, 0x72, 0xEC, 0x71, 
                0x76, 0xEC, 0x54, 0x8E, 0x1F, 0x85, 0x0C, 0x01, 
                0x6A, 0xFA, 0xA6, 0x38, 0xAC, 0x1F, 0xC4, 0x84
    };
    BYTE mod[] =
    {
                0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85, 
                0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2, 
                0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32, 
                0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9, 
                0x76, 0x3F, 0xE3, 0x9C, 0xB6, 0x37, 0x79, 0x03, 
                0xB9, 0xAB, 0x69, 0x8D, 0x07, 0x25, 0xB6, 0x19, 
                0x67, 0xE4, 0xB0, 0x1B, 0x18, 0x73, 0x61, 0x4A, 
                0xE8, 0x7E, 0xCD, 0xD3, 0x2F, 0x64, 0xE3, 0xA6, 
                0x7C, 0x0C, 0xFA, 0x17, 0x80, 0xA3, 0x0D, 0x47, 
                0x89, 0x4F, 0x51, 0x71, 0x2F, 0xEE, 0xFC, 0x3F, 
                0xF9, 0xB8, 0x16, 0x80, 0x87, 0x89, 0x93, 0x25, 
                0x20, 0x9A, 0x43, 0x82, 0x69, 0x24, 0x76, 0x28, 
                0x59, 0x35, 0xA1, 0x1D, 0xC0, 0x7F, 0x83, 0x06, 
                0x64, 0x16, 0x20, 0x2C, 0xD3, 0x49, 0xA4, 0x85, 
                0xB4, 0xC0, 0x61, 0x7F, 0x51, 0x08, 0xF8, 0x68, 
                0x15, 0x91, 0x80, 0xCB, 0xA5, 0xD5, 0xEE, 0x3B, 
                0x3A, 0xF4, 0x84, 0x04, 0x5E, 0x60, 0x59, 0xA7, 
                0x8C, 0x34, 0x72, 0xEE, 0xB8, 0x78, 0xC5, 0xD1, 
                0x3B, 0x12, 0x4A, 0x6F, 0x7E, 0x65, 0x27, 0xB9, 
                0xA4, 0x55, 0xC5, 0xB9, 0x6F, 0x43, 0xA4, 0xC5, 
                0x1D, 0x2C, 0x99, 0xC0, 0x52, 0xA4, 0x78, 0x4C, 
                0x15, 0xB3, 0x40, 0x98, 0x08, 0x6B, 0x43, 0xC6, 
                0x01, 0xB0, 0x7A, 0x7B, 0xF5, 0x6B, 0x1C, 0x22, 
                0x3F, 0xCB, 0xEF, 0xFF, 0xA8, 0xD0, 0x3A, 0x4B, 
                0x76, 0x15, 0x9E, 0xD2, 0xD1, 0xC6, 0x2E, 0xE3, 
                0xDB, 0x57, 0x1B, 0x32, 0xA2, 0xB8, 0x6F, 0xE8, 
                0x86, 0xA6, 0x3F, 0x70, 0xAB, 0xE5, 0x70, 0x92, 
                0xAB, 0x44, 0x1E, 0x40, 0x50, 0xFB, 0x9C, 0xA3, 
                0x62, 0xE4, 0x6C, 0x6E, 0xA0, 0xC8, 0xDE, 0xE2, 
                0x80, 0x42, 0xFA, 0xE9, 0x2F, 0xE8, 0xCE, 0x32, 
                0x04, 0x8F, 0x7C, 0x8D, 0xB7, 0x1C, 0xA3, 0x35, 
                0x3C, 0x15, 0xDD, 0x9E, 0xC3, 0xAE, 0x97, 0xA5
    };

    lint( A, sig );
    lint( N, mod );
    RESULT r      = 0;
    /* TODO: make sure its even ? */

    SHORT R_t     = N->top + 1;
    /* get the size based on R_t rounded
       to the next byte */
    SHORT R_s     = ( R_t +
                    ( SIZEOF_BYTE - (R_t & 0x7F) ) )
                    >> 3;
    /* 16 bit align since we multiply
       shorts */
    R_s = (R_s & 1)? (R_s + 1) : R_s;

    SHORT AR_s    = R_s + A->size;
    AR_s          = (AR_s & 1)? (AR_s + 1) : AR_s;
    SHORT M_s     = AR_s+4;

    /* TODO: change to lshiftBuf ASAP */
    mint( AR, AR_s );

    copy( AR, A );
    printf( "R_t [%u]\n", R_t );
    lshift( AR, R_t );

    /*
    printInteger( A );
    printf("*");
    printInteger( R );
    printf("=");
    printInteger( AR );
    printf("\n");
    */
    mint( M,   M_s );
    mint( Q,   div_q_sz_y_zero(AR, M) );
    /* AR = A*R mod N */

    /*
    printf( "mod(");
    printInteger( AR );
    printf(",");
    */

    if( ( r = divide( AR, N, Q, M ) ) != OK )
    {
        r = -1;
        goto done;
    }
no_mem_:
    r = NO_MEM;
done:
    flint( AR );
    flint( Q );
    flint( M );
    return r;
}

int test_modexp()
{
    {

        /* modular exponentiation */
        BYTE Ab [] = { 0x66, 0xDE, 0xFF, 0x31, 0x52, 0x48 };
        /* 65281 */
        BYTE Nn [] = { 0xFF, 0x31, 0x52, 0x41, 0x99, 0x01  };
        /*
        BYTE Ee [] = { 0x10, 0x00, 0x01  };
        */
        BYTE Ee [] = { 0x01, 0x00, 0x01  };
        RESULT r = 0;
        lint( A, Ab );
        lint( N, Nn );
        lint( E, Ee );
        mint( R, 64 );
        printf( "\n*** test Montgomery modular exponentiation ***\n" );
        printInteger ( A );
        printf("^");
        printInteger ( E );
        printf(" mod ");
        printInteger ( N );
        printf(" = ");
        r = mont_modexp_n( A, E, N, R );
        printInteger ( R );
        printf( "[%d][%s]\n", r, (r == OK)? "OK":"Failed" );
    }
    goto done;
no_mem_:
    return NO_MEM;
done:
    return OK;
}

int test_div_small_quo1(void)
{
    BYTE a_[] = { 0x91, 0x90, 0x92, 0x93 };
    BYTE b_[] = { 0x91, 0x90, 0x92, 0x93 };
    BYTE exp_Q[] = { 0x00, 0x00, 0x00, 0x01 };
    BYTE exp_R[] = { 0x00, 0x00, 0x00, 0x00 };
    lint( A, a_ );
    lint( B, b_ );
    clint( R, 8 );
    clint( Q, 4 );
    divide( A, B, Q, R );
    printf( "A = \n" );
    printInteger( A );
    printf( "\n B = \n" );
    printInteger( B );
    printf( "\n Q = \n " );
    printInteger( Q );
    printf( "\n R = \n " );
    printInteger( A );
    printf( "\n " );
    if( memcmp( Q->buf, exp_Q, sizeof( exp_Q ) ) != 0 )
        return QUOTIENT_INCORRECT;
    if( memcmp( R->buf, exp_R, sizeof( exp_R ) ) != 0 )
        return REM_INCORRECT;
    return OK;
}

int test_div_small_quo2(void)
{
    int res;
    BYTE k[] = { 0xAD, 0xBC, 0xDD, 0xFF, 0xDC, 0xFF };
    BYTE m[] = { 0x01, 0x00, 0x00, 0x00, 0x01 };
    lint( A, k );
    lint( B, m );
    mint( Q, div_q_sz(A, B) );
    mint( R, A->size + 4 );
    res = divide( A, B, Q, R );
    goto done;
no_mem_:
    res = NO_MEM;
done:
    flint( Q );
    flint( R );
    return res;
}
int test_div_small_quo3(void)
{
    int res;
    BYTE k[] = { 0x01, 0x00, 0x00, 0x00, 0x00 };
    BYTE m[] = { 0xFF, 0xFF, 0xFF, 0xFF };
    lint( A, k );
    lint( B, m );
    mint( Q, div_q_sz(A, B) );
    mint( R, A->size + 4 );
    res = divide( A, B, Q, R );
    goto done;
no_mem_:
    res = NO_MEM;
done:
    flint( Q );
    flint( R );
    return res;
}

int test_div_small_quo4(void)
{
    int res;
    BYTE k[] = { 0x01, 0x49, 0xE6, 0x4B, 0x99, 0xA3, 0xA9, 
                 0x23, 0x06, 0x45, 0xA1, 0x98, 0x65, 0x57 };
    BYTE m[] = { 0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36 };
    lint( A, k );
    lint( B, m );
    mint( Q, div_q_sz(A, B) );
    mint( R, A->size + 4 );
    res = divide( A, B, Q, R );
    goto done;
no_mem_:
    res = NO_MEM;
done:
    flint( Q );
    flint( R );
    return res;
}

int test_div_small_quo5(void)
{
    int res;
    BYTE k[] = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    BYTE m[] = { 0xFF, 0xFF, 0xFF, 0xFF };
    lint( A, k );
    lint( B, m );
    mint( Q, div_q_sz(A, B) );
    mint( R, A->size + 4 );
    res = divide( A, B, Q, R );
    goto done;
no_mem_:
    res = NO_MEM;
done:
    flint( Q );
    flint( R );
    return res;
}

int test_div_small_quo6(void)
{
    int res;
    BYTE k[] = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    BYTE m[] = { 0x01, 0x00, 0x00, 0x01 };
    lint( A, k );
    lint( B, m );
    mint( Q, div_q_sz(A, B) );
    mint( R, A->size + 4 );
    res = divide( A, B, Q, R );
    goto done;
no_mem_:
    res = NO_MEM;
done:
    flint( Q );
    flint( R );
    return res;
}

int test_div_smallbuf_1(void)
{
    int res;
    res = test_div_small_quo1();
    if( res != OK )
        printf( "test_div_small_quo1 failed \n" );
    res = test_div_small_quo2();
    if( res != OK )
        printf( "test_div_small_quo2 failed \n" );
    res = test_div_small_quo3();
    if( res != OK )
        printf( "test_div_small_quo3 failed \n" );
    res = test_div_small_quo4();
    if( res != OK )
        printf( "test_div_small_quo4 failed \n" );
    res = test_div_small_quo5();
    if( res != OK )
        printf( "test_div_small_quo5 failed \n" );
    res = test_div_small_quo6();
    if( res != OK )
        printf( "test_div_small_quo6 failed \n" );
    return res;
}

int test_mod_barrett(void)
{
    RESULT _res_ = 0;
    /*
    BYTE a_[] = {
                0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85, 
                0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2, 
                0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32, 
                0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9, 
                0x76, 0x3F, 0xE3, 0x9C, 0xB6, 0x37, 0x79, 0x03, 
                0xB9, 0xAB, 0x69, 0x8D, 0x07, 0x25, 0xB6, 0x19, 
                0x67, 0xE4, 0xB0, 0x1B, 0x18, 0x73, 0x61, 0x4A, 
                0xE8, 0x7E, 0xCD, 0xD3, 0x2F, 0x64, 0xE3, 0xA6, 
                0x7C, 0x0C, 0xFA, 0x17, 0x80, 0xA3, 0x0D, 0x47, 
                0x89, 0x4F, 0x51, 0x71, 0x2F, 0xEE, 0xFC, 0x3F, 
                0xF9, 0xB8, 0x16, 0x80, 0x87, 0x89, 0x93, 0x25, 
                0x20, 0x9A, 0x43, 0x82, 0x69, 0x24, 0x76, 0x28, 
                0x59, 0x35, 0xA1, 0x1D, 0xC0, 0x7F, 0x83, 0x06, 
                0x64, 0x16, 0x20, 0x2C, 0xD3, 0x49, 0xA4, 0x85, 
                0xB4, 0xC0, 0x61, 0x7F, 0x51, 0x08, 0xF8, 0x68, 
                0x15, 0x91, 0x80, 0xCB, 0xA5, 0xD5, 0xEE, 0x3B, 
                0x3A, 0xF4, 0x84, 0x04, 0x5E, 0x60, 0x59, 0xA7, 
                0x8C, 0x34, 0x72, 0xEE, 0xB8, 0x78, 0xC5, 0xD1, 
                0x3B, 0x12, 0x4A, 0x6F, 0x7E, 0x65, 0x27, 0xB9, 
                0xA4, 0x55, 0xC5, 0xB9, 0x6F, 0x43, 0xA4, 0xC5, 
                0x1D, 0x2C, 0x99, 0xC0, 0x52, 0xA4, 0x78, 0x4C, 
                0x15, 0xB3, 0x40, 0x98, 0x08, 0x6B, 0x43, 0xC6, 
                0x01, 0xB0, 0x7A, 0x7B, 0xF5, 0x6B, 0x1C, 0x22, 
                0x3F, 0xCB, 0xEF, 0xFF, 0xA8, 0xD0, 0x3A, 0x4B, 
                0x76, 0x15, 0x9E, 0xD2, 0xD1, 0xC6, 0x2E, 0xE3, 
                0xDB, 0x57, 0x1B, 0x32, 0xA2, 0xB8, 0x6F, 0xE8, 
                0x86, 0xA6, 0x3F, 0x70, 0xAB, 0xE5, 0x70, 0x92, 
                0xAB, 0x44, 0x1E, 0x40, 0x50, 0xFB, 0x9C, 0xA3, 
                0x62, 0xE4, 0x6C, 0x6E, 0xA0, 0xC8, 0xDE, 0xE2, 
                0x80, 0x42, 0xFA, 0xE9, 0x2F, 0xE8, 0xCE, 0x32, 
                0x04, 0x8F, 0x7C, 0x8D, 0xB7, 0x1C, 0xA3, 0x35, 
                0x3C, 0x15, 0xDD, 0x9E, 0xC3, 0xAE, 0x97, 0xA5
    };
    */
    BYTE a1[] = {
                0xB3, 0xFB, 0x91, 0xA1, 0xE4, 0x36, 0x55, 0x85, 
                0xAC, 0x06, 0x34, 0x5B, 0xA0, 0x9A, 0x58, 0xB2, 
                0xF8, 0xB5, 0x0F, 0x05, 0x77, 0x83, 0xAE, 0x32, 
                0xB1, 0x76, 0x92, 0x68, 0xEC, 0x23, 0x4A, 0xC9, 
                0x76, 0x3F, 0xE3, 0x9C, 0xB6, 0x37, 0x79, 0x03
    };
    BYTE SECP160R1_n[] =
    {
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x01, 0xF4, 0xC8, 0xF9, 0x27, 0xAE,
            0xD3, 0xCA, 0x75, 0x22, 0x57
    };
    dint( B, SECP160R1_n, sizeof(SECP160R1_n));
    lint( A, a1 );
    Integer R;
    _res_ = mod_barrett( A, B, &R );
    goto done;
no_mem_:
    _res_ = NO_MEM;
done:
    flint( B );
    flint( R );
    return _res_;
}



int test_mod_inv_basic(void)
{
    BYTE _s[] = {0xFD, 0x62, 0x13, 0x0F, 0xA5, 0x66, 0x0F, 0x97};
    BYTE _n[] = {0xFE, 0xAA, 0x9A, 0x5D, 0x78, 0x00, 0x50, 0x2B};
    dint( n, _n, sizeof( _n ) );
    dint( s, _s, sizeof( _s ) );

    mint( s1, 2*sizeof( _s ) );
    printf( "\n gcd.sh " );
    printInteger( s );
    printf( " " );
    printInteger( n );
    printf( "\n" );
    modinv( s, n, s1 );
    printf( "\n sInv \n " );
    printInteger( s1 );
    printf( " = " );

    printf( HEXCALC_OPEN "mod(" );
    printInteger( s1 );
    printf( "*" );
    printInteger( s );
    printf( "," );
    printInteger( n );
    printf( ")" HEXCALC_CLOSE " = 1\n" );

no_mem_:
    flint( n );
    flint( s );
    flint( s1 );
    return 0;
}
