#include "aes.h"
/* FIPS 197
+-------------------------------------------------------
|         | Key Length | Block Size | Number of Rounds |
|         | (Nk words) | (Nb words) |  (Nr)            |
+------------------------------------------------------+
| AES-128 |     4      |   4        |  10              |
| AES-192 |     6      |   4        |  12              |
| AES-256 |     8      |   4        |  14              |
+------------------------------------------------------+
*/

static BYTE Sbox[256] ONFLASH =
{
0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

static BYTE InvSbox[256] ONFLASH =
{
0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

static BYTE Xtime2Sbox [256] ONFLASH=
{
0xc6, 0xf8, 0xee, 0xf6, 0xff, 0xd6, 0xde, 0x91, 0x60, 0x02, 0xce, 0x56, 0xe7, 0xb5, 0x4d, 0xec, 
0x8f, 0x1f, 0x89, 0xfa, 0xef, 0xb2, 0x8e, 0xfb, 0x41, 0xb3, 0x5f, 0x45, 0x23, 0x53, 0xe4, 0x9b, 
0x75, 0xe1, 0x3d, 0x4c, 0x6c, 0x7e, 0xf5, 0x83, 0x68, 0x51, 0xd1, 0xf9, 0xe2, 0xab, 0x62, 0x2a, 
0x08, 0x95, 0x46, 0x9d, 0x30, 0x37, 0x0a, 0x2f, 0x0e, 0x24, 0x1b, 0xdf, 0xcd, 0x4e, 0x7f, 0xea, 
0x12, 0x1d, 0x58, 0x34, 0x36, 0xdc, 0xb4, 0x5b, 0xa4, 0x76, 0xb7, 0x7d, 0x52, 0xdd, 0x5e, 0x13, 
0xa6, 0xb9, 0x00, 0xc1, 0x40, 0xe3, 0x79, 0xb6, 0xd4, 0x8d, 0x67, 0x72, 0x94, 0x98, 0xb0, 0x85, 
0xbb, 0xc5, 0x4f, 0xed, 0x86, 0x9a, 0x66, 0x11, 0x8a, 0xe9, 0x04, 0xfe, 0xa0, 0x78, 0x25, 0x4b, 
0xa2, 0x5d, 0x80, 0x05, 0x3f, 0x21, 0x70, 0xf1, 0x63, 0x77, 0xaf, 0x42, 0x20, 0xe5, 0xfd, 0xbf, 
0x81, 0x18, 0x26, 0xc3, 0xbe, 0x35, 0x88, 0x2e, 0x93, 0x55, 0xfc, 0x7a, 0xc8, 0xba, 0x32, 0xe6, 
0xc0, 0x19, 0x9e, 0xa3, 0x44, 0x54, 0x3b, 0x0b, 0x8c, 0xc7, 0x6b, 0x28, 0xa7, 0xbc, 0x16, 0xad, 
0xdb, 0x64, 0x74, 0x14, 0x92, 0x0c, 0x48, 0xb8, 0x9f, 0xbd, 0x43, 0xc4, 0x39, 0x31, 0xd3, 0xf2, 
0xd5, 0x8b, 0x6e, 0xda, 0x01, 0xb1, 0x9c, 0x49, 0xd8, 0xac, 0xf3, 0xcf, 0xca, 0xf4, 0x47, 0x10, 
0x6f, 0xf0, 0x4a, 0x5c, 0x38, 0x57, 0x73, 0x97, 0xcb, 0xa1, 0xe8, 0x3e, 0x96, 0x61, 0x0d, 0x0f, 
0xe0, 0x7c, 0x71, 0xcc, 0x90, 0x06, 0xf7, 0x1c, 0xc2, 0x6a, 0xae, 0x69, 0x17, 0x99, 0x3a, 0x27, 
0xd9, 0xeb, 0x2b, 0x22, 0xd2, 0xa9, 0x07, 0x33, 0x2d, 0x3c, 0x15, 0xc9, 0x87, 0xaa, 0x50, 0xa5, 
0x03, 0x59, 0x09, 0x1a, 0x65, 0xd7, 0x84, 0xd0, 0x82, 0x29, 0x5a, 0x1e, 0x7b, 0xa8, 0x6d, 0x2c 
};

static BYTE Xtime3Sbox[256] ONFLASH =
{
0xa5, 0x84, 0x99, 0x8d, 0x0d, 0xbd, 0xb1, 0x54, 0x50, 0x03, 0xa9, 0x7d, 0x19, 0x62, 0xe6, 0x9a, 
0x45, 0x9d, 0x40, 0x87, 0x15, 0xeb, 0xc9, 0x0b, 0xec, 0x67, 0xfd, 0xea, 0xbf, 0xf7, 0x96, 0x5b, 
0xc2, 0x1c, 0xae, 0x6a, 0x5a, 0x41, 0x02, 0x4f, 0x5c, 0xf4, 0x34, 0x08, 0x93, 0x73, 0x53, 0x3f, 
0x0c, 0x52, 0x65, 0x5e, 0x28, 0xa1, 0x0f, 0xb5, 0x09, 0x36, 0x9b, 0x3d, 0x26, 0x69, 0xcd, 0x9f, 
0x1b, 0x9e, 0x74, 0x2e, 0x2d, 0xb2, 0xee, 0xfb, 0xf6, 0x4d, 0x61, 0xce, 0x7b, 0x3e, 0x71, 0x97, 
0xf5, 0x68, 0x00, 0x2c, 0x60, 0x1f, 0xc8, 0xed, 0xbe, 0x46, 0xd9, 0x4b, 0xde, 0xd4, 0xe8, 0x4a, 
0x6b, 0x2a, 0xe5, 0x16, 0xc5, 0xd7, 0x55, 0x94, 0xcf, 0x10, 0x06, 0x81, 0xf0, 0x44, 0xba, 0xe3, 
0xf3, 0xfe, 0xc0, 0x8a, 0xad, 0xbc, 0x48, 0x04, 0xdf, 0xc1, 0x75, 0x63, 0x30, 0x1a, 0x0e, 0x6d, 
0x4c, 0x14, 0x35, 0x2f, 0xe1, 0xa2, 0xcc, 0x39, 0x57, 0xf2, 0x82, 0x47, 0xac, 0xe7, 0x2b, 0x95, 
0xa0, 0x98, 0xd1, 0x7f, 0x66, 0x7e, 0xab, 0x83, 0xca, 0x29, 0xd3, 0x3c, 0x79, 0xe2, 0x1d, 0x76, 
0x3b, 0x56, 0x4e, 0x1e, 0xdb, 0x0a, 0x6c, 0xe4, 0x5d, 0x6e, 0xef, 0xa6, 0xa8, 0xa4, 0x37, 0x8b, 
0x32, 0x43, 0x59, 0xb7, 0x8c, 0x64, 0xd2, 0xe0, 0xb4, 0xfa, 0x07, 0x25, 0xaf, 0x8e, 0xe9, 0x18, 
0xd5, 0x88, 0x6f, 0x72, 0x24, 0xf1, 0xc7, 0x51, 0x23, 0x7c, 0x9c, 0x21, 0xdd, 0xdc, 0x86, 0x85, 
0x90, 0x42, 0xc4, 0xaa, 0xd8, 0x05, 0x01, 0x12, 0xa3, 0x5f, 0xf9, 0xd0, 0x91, 0x58, 0x27, 0xb9, 
0x38, 0x13, 0xb3, 0x33, 0xbb, 0x70, 0x89, 0xa7, 0xb6, 0x22, 0x92, 0x20, 0x49, 0xff, 0x78, 0x7a, 
0x8f, 0xf8, 0x80, 0x17, 0xda, 0x31, 0xc6, 0xb8, 0xc3, 0xb0, 0x77, 0x11, 0xcb, 0xfc, 0xd6, 0x3a 
};

/* FIPS 197
 * Multiplying the binary polynomial defined in equation (3.1) with the polynomial x results in
 * b7 x 8 + b6 x 7 + b5 x 6 + b4 x 5 + b3 x 4 + b2 x 3 + b1 x 2 + b0 x .
 * (4.4)
 * The result x.b(x) is obtained by reducing the above result modulo m(x), as defined in
 * equation (4.1). If b7 = 0, the result is already in reduced form. If b7 = 1, the reduction
 * is accomplished by subtracting (i.e., XORing) the polynomial m(x). It follows that
 * multiplication by x (i.e.,{00000010} or {02}) can be implemented at the byte level as a
 * left shift and a subsequent conditional bitwise XOR with {1b}. This operation on bytes is
 * denoted by xtime(). Multiplication by higher powers of x can be implemented by repeated
 * application of xtime(). By adding intermediate results, multiplication by any constant
 * can be implemented.
 *  Xtime2[x] = (x & 0x80 ? 0x1b : 0)^(x<<1)

static BYTE ONFLASH Xtime2[256] =
{
0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 
0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 
0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 
0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 
0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 
0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 
0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 
0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 
0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 
0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 
0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 
0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 
0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 
0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 
0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 
0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
};
 */

static BYTE Xtime9[256] ONFLASH =
{
0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77, 
0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 
0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c, 
0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc, 
0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01, 
0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91, 
0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a, 
0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 
0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b, 
0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b, 
0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 
0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30, 
0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed, 
0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 
0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6, 
0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46
};

static BYTE XtimeB[256] ONFLASH =
{
0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69, 
0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 
0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12, 
0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2, 
0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 
0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f, 
0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4, 
0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 
0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e, 
0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e, 
0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 
0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55, 
0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68, 
0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 
0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13, 
0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3
};

static BYTE XtimeD[256] ONFLASH =
{
0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b, 
0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 
0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0, 
0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20, 
0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 
0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6, 
0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d, 
0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 
0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91, 
0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41, 
0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 
0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa, 
0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc, 
0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 
0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47, 
0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97
};

static BYTE XtimeE[256] ONFLASH =
{
0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a, 
0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 
0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81, 
0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61, 
0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 
0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17, 
0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c, 
0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 
0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b, 
0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb, 
0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 
0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20, 
0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6, 
0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 
0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d, 
0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d
};

static BYTE Rcon[11] ONFLASH = 
{
0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36  
};

void aes_expand_key( BYTE* key, BYTE* w )
{
    BYTE t0, t1, t2, t3, t4;
    memcpy( w, key, Nk * 4 );
    SHORT i;

    memcpy (w, key, Nk * 4);

    for( i = Nk; i < Nb * (Nr + 1); i++ )
    {
        t0 = w[4*i - 4];
        t1 = w[4*i - 3];
        t2 = w[4*i - 2];
        t3 = w[4*i - 1];
        if( !(i % Nk) )
        {
            t4 = t3;
            t3 = Sbox[t0];
            t0 = Sbox[t1] ^ Rcon[i/Nk];
            t1 = Sbox[t2];
            t2 = Sbox[t4];
        } else if( Nk > 6 && i % Nk == 4 )
        {
            t0 = Sbox[t0];
            t1 = Sbox[t1];
            t2 = Sbox[t2];
            t3 = Sbox[t3];
        }
        w[4*i+0] = w[4*i - 4*Nk + 0] ^ t0;
        w[4*i+1] = w[4*i - 4*Nk + 1] ^ t1;
        w[4*i+2] = w[4*i - 4*Nk + 2] ^ t2;
        w[4*i+3] = w[4*i - 4*Nk + 3] ^ t3;
    }
}


void aes_shift_rows(BYTE *state)
{
    BYTE tmp;

    // just substitute row 0
    state[0] = Sbox[state[0]], state[4] = Sbox[state[4]];
    state[8] = Sbox[state[8]], state[12] = Sbox[state[12]];

    // rotate row 1
    tmp = Sbox[state[1]], state[1] = Sbox[state[5]];
    state[5] = Sbox[state[9]], state[9] =
    Sbox[state[13]], state[13] = tmp;

    // rotate row 2
    tmp = Sbox[state[2]], state[2] = Sbox[state[10]], state[10] = tmp;
    tmp = Sbox[state[6]], state[6] = Sbox[state[14]], state[14] = tmp;

    // rotate row 3
    tmp = Sbox[state[15]], state[15] = Sbox[state[11]];
    state[11] = Sbox[state[7]], state[7] =
    Sbox[state[3]], state[3] = tmp;
}

void aes_inv_shift_rows(BYTE *state)
{
    BYTE tmp;

    // restore row 0
    state[0] = InvSbox[state[0]], state[4]  = InvSbox[state[4]];
    state[8] = InvSbox[state[8]], state[12] = InvSbox[state[12]];

    // restore row 1
    tmp = InvSbox[state[13]], state[13]    = InvSbox[state[9]];
    state[9] = InvSbox[state[5]], state[5] = InvSbox[state[1]],
    state[1] = tmp;

    // restore row 2
    tmp = InvSbox[state[2]], state[2] =
    InvSbox[state[10]], state[10] = tmp;
    tmp = InvSbox[state[6]], state[6] =
    InvSbox[state[14]], state[14] = tmp;

    // restore row 3
    tmp = InvSbox[state[3]], state[3] = InvSbox[state[7]];
    state[7] = InvSbox[state[11]], state[11] = InvSbox[state[15]],
    state[15] = tmp;
}

/* FIPS 197
 * s0,c = ({02}.s0,c ) ^ ({03}.s1,c )^s2,c^s3,c
 * s1,c = s0,c^({02}.s1,c )^({03}.s 2,c )^s3,c
 * s2,c = s0,c^s1,c^({02}.s 2,c )^({03}.s3,c )
 * s3,c = ({03}.s0,c )^s1,c^s 2,c^({02}.s3,c )
 */
void aes_mix_sub_columns(BYTE *state)
{
    BYTE tmp[4 * Nb];

    tmp[0] =    Xtime2Sbox[state[0]] ^  Xtime3Sbox[state[5]]
             ^       Sbox[state[10]] ^       Sbox[state[15]];
    tmp[1] =          Sbox[state[0]] ^  Xtime2Sbox[state[5]]
             ^ Xtime3Sbox[state[10]] ^       Sbox[state[15]];
    tmp[2] =          Sbox[state[0]] ^        Sbox[state[5]]
             ^ Xtime2Sbox[state[10]] ^ Xtime3Sbox[state[15]];
    tmp[3] =    Xtime3Sbox[state[0]] ^        Sbox[state[5]]
             ^       Sbox[state[10]] ^ Xtime2Sbox[state[15]];

    tmp[4] =    Xtime2Sbox[state[4]] ^  Xtime3Sbox[state[9]]
             ^       Sbox[state[14]] ^        Sbox[state[3]];
    tmp[5] =          Sbox[state[4]] ^  Xtime2Sbox[state[9]]
             ^ Xtime3Sbox[state[14]] ^        Sbox[state[3]];
    tmp[6] =          Sbox[state[4]] ^        Sbox[state[9]]
             ^ Xtime2Sbox[state[14]] ^  Xtime3Sbox[state[3]];
    tmp[7] =    Xtime3Sbox[state[4]] ^        Sbox[state[9]]
             ^       Sbox[state[14]] ^  Xtime2Sbox[state[3]];

    tmp[8] =    Xtime2Sbox[state[8]] ^ Xtime3Sbox[state[13]]
             ^        Sbox[state[2]] ^        Sbox[state[7]];
    tmp[9] =          Sbox[state[8]] ^ Xtime2Sbox[state[13]]
             ^  Xtime3Sbox[state[2]] ^        Sbox[state[7]];
    tmp[10] =         Sbox[state[8]] ^       Sbox[state[13]]
              ^ Xtime2Sbox[state[2]] ^  Xtime3Sbox[state[7]];
    tmp[11] =   Xtime3Sbox[state[8]] ^       Sbox[state[13]]
              ^       Sbox[state[2]] ^  Xtime2Sbox[state[7]];

    tmp[12] =  Xtime2Sbox[state[12]] ^  Xtime3Sbox[state[1]]
              ^       Sbox[state[6]] ^       Sbox[state[11]];
    tmp[13] =        Sbox[state[12]] ^  Xtime2Sbox[state[1]]
              ^ Xtime3Sbox[state[6]] ^       Sbox[state[11]];
    tmp[14] =        Sbox[state[12]] ^        Sbox[state[1]]
              ^ Xtime2Sbox[state[6]] ^ Xtime3Sbox[state[11]];
    tmp[15] =  Xtime3Sbox[state[12]] ^        Sbox[state[1]]
                    ^ Sbox[state[6]] ^ Xtime2Sbox[state[11]];

    memcpy (state, tmp, sizeof(tmp));
}
/* FIPS 197
s0,c = ({0e}.s0,c )^({0b}.s1,c )^({0d}.s 2,c )^({09}.s3.c )
s1,c = ({09}.s0,c )^({0e}.s1,c )^({0b}.s 2,c )^({0d}.s3,c )
s2c  = ({0d}.s0,c )^({09}.s1,c )^({0e}.s 2,c )^({0b}.s3,c )
s3,c = ({0b}.s0,c )^({0d}.s1,c )^({09}.s 2,c )^({0e}.s3,c )
*/
void aes_inv_mix_sub_columns(BYTE *state)
{
    BYTE tmp[4 * Nb];
    SHORT i;

    tmp[0] =        XtimeE[state[0]] ^      XtimeB[state[1]]
              ^     XtimeD[state[2]] ^      Xtime9[state[3]];
    tmp[5] =        Xtime9[state[0]] ^      XtimeE[state[1]]
              ^     XtimeB[state[2]] ^      XtimeD[state[3]];
    tmp[10] =       XtimeD[state[0]] ^      Xtime9[state[1]]
              ^     XtimeE[state[2]] ^      XtimeB[state[3]];
    tmp[15] =       XtimeB[state[0]] ^      XtimeD[state[1]]
              ^     Xtime9[state[2]] ^      XtimeE[state[3]];

    tmp[4] =        XtimeE[state[4]] ^      XtimeB[state[5]]
              ^     XtimeD[state[6]] ^      Xtime9[state[7]];
    tmp[9] =        Xtime9[state[4]] ^      XtimeE[state[5]]
              ^     XtimeB[state[6]] ^      XtimeD[state[7]];
    tmp[14] =       XtimeD[state[4]] ^      Xtime9[state[5]]
              ^     XtimeE[state[6]] ^      XtimeB[state[7]];
    tmp[3] =        XtimeB[state[4]] ^      XtimeD[state[5]]
              ^     Xtime9[state[6]] ^      XtimeE[state[7]];

    tmp[8]  =       XtimeE[state[8]] ^      XtimeB[state[9]]
                 ^ XtimeD[state[10]] ^     Xtime9[state[11]];
    tmp[13] =       Xtime9[state[8]] ^      XtimeE[state[9]]
                 ^ XtimeB[state[10]] ^     XtimeD[state[11]];
    tmp[2]  =       XtimeD[state[8]] ^      Xtime9[state[9]]
                 ^ XtimeE[state[10]] ^     XtimeB[state[11]];
    tmp[7]  =       XtimeB[state[8]] ^      XtimeD[state[9]]
                 ^ Xtime9[state[10]] ^     XtimeE[state[11]];

    tmp[12] =      XtimeE[state[12]] ^     XtimeB[state[13]]
                 ^ XtimeD[state[14]] ^     Xtime9[state[15]];
    tmp[1]  =      Xtime9[state[12]] ^     XtimeE[state[13]]
                 ^ XtimeB[state[14]] ^     XtimeD[state[15]];
    tmp[6]  =      XtimeD[state[12]] ^     Xtime9[state[13]]
                 ^ XtimeE[state[14]] ^     XtimeB[state[15]];
    tmp[11] =      XtimeB[state[12]] ^     XtimeD[state[13]]
                 ^ Xtime9[state[14]] ^     XtimeE[state[15]];

    for( i=0; i < 4 * Nb; i++ )
            state[i] = InvSbox[tmp[i]];
}

#define aes_xor_block( a, b )                 \
    (a)[0]  ^= (b)[0];   (a)[1]   ^= (b)[1];  \
    (a)[2]  ^= (b)[2];   (a)[3]   ^= (b)[3];  \
    (a)[4]  ^= (b)[4];   (a)[5]   ^= (b)[5];  \
    (a)[6]  ^= (b)[6];   (a)[7]   ^= (b)[7];  \
    (a)[8]  ^= (b)[8];   (a)[9]   ^= (b)[9];  \
    (a)[10] ^= (b)[10]; (a)[11]   ^= (b)[11]; \
    (a)[12] ^= (b)[12]; (a)[13]   ^= (b)[13]; \
    (a)[14] ^= (b)[14]; (a)[15]   ^= (b)[15]

#define aes_add_round_key aes_xor_block

/*!
  \brief  : aes-128 encrypt one block of input
  \param 1: [IN] input block of plaintext
  \param 2: [IN] expanded key. This is not the same as the
                 original key, but rather the original key
                 expanded to (Nr + 1 * Nb) * sizeof(WORD)
                 = 44 * 4 = 176 bytes for aes-128-cbc.
                 Assumes caller has called
                 BYTE mkey[CIPH_KEY_SZ];
                 aes_expand_key( key, mkey );
                 before
  \param 3: [OUT] output bock of ciphertext. It can point
                 point to the same location as param 1,
                 meaning aes_decrypt(x, k, x) is legal
*/
void aes_encrypt (BYTE *in, BYTE *expkey, BYTE *out)
{
    BYTE state[Nb * 4];
    WORD round;
    memcpy( state, in, Nb * 4 );
    aes_add_round_key( state, expkey );
    for( round = 1; round < Nr + 1; round++ )
    {
        if( round < Nr )
            aes_mix_sub_columns (state);
        else
            aes_shift_rows (state);
        aes_add_round_key( state, expkey + (round * CIPH_BLOCK_SZ) );
    }
    memcpy( out, state, sizeof(state) );
}

/*!
  \brief  : aes-128 decrypt one block of input
  \param 1: [IN] input block of ciphertext
  \param 2: [IN] key, encryption key 16 bytes allocated by
                 caller on stack or heap
                 This is not the same as the
                 original key, but rather the original key
                 expanded to (Nr + 1 * Nb) * sizeof(WORD)
                 = 44 * 4 = 176 bytes for aes-128-cbc.
                 Assumes caller has called
                 BYTE mkey[CIPH_KEY_SZ];
                 aes_expand_key( key, mkey );
  \param 3: [OUT] output bock of plaintext. It can point
                 point to the same location as param 1,
                 meaning aes_decrypt(x, k, x) is legal
*/
void aes_decrypt(BYTE *in, BYTE *expkey, BYTE *out)
{
    BYTE state[Nb * 4];
    BYTE round;
    memcpy( state, in, sizeof(state) );
    aes_add_round_key( state, expkey + (Nr * CIPH_BLOCK_SZ) );
    aes_inv_shift_rows(state);
    for( round = Nr; round--; )
    {
        aes_add_round_key(state, expkey + (round * CIPH_BLOCK_SZ) );
        if( round )
            aes_inv_mix_sub_columns (state);
    }
    memcpy(out, state, sizeof(state));
}

/*!
  \brief  : aes-128-cbc decrypt input ciphertext
  \param 1: [IN] iv, initialization vector 16 bytes allocated
                 by caller on stack or heap
  \param 2: [IN] key, encryption key 16 bytes allocated by
                 caller on stack or heap
  \param 3: [INOUT] cipher text is converted to plaintext
                    in place
  \param 4: [IN] length of ciphertext in param 3
  \return : 
*/
SHORT aes_cbc_decrypt( BYTE* iv , BYTE* key,
                      BYTE* ob , SHORT osz )
{
    BYTE i = 0;
    BYTE* c = ob;
    BYTE mkey[CIPH_KEY_SZ];
    BYTE niv[ CIPH_BLOCK_SZ ];
    BYTE civ[ CIPH_BLOCK_SZ ];
    memcpy( civ, iv, CIPH_BLOCK_SZ );
    BYTE numBlocks = (osz >> 4);
    aes_expand_key( key, mkey );
    for( ; i < numBlocks; i++ )
    {
        c = ob + i*CIPH_BLOCK_SZ;
        memcpy( niv, c, CIPH_BLOCK_SZ );
        aes_decrypt(c, mkey, c);
        aes_xor_block( c, civ );
        memcpy( civ, niv, CIPH_BLOCK_SZ );
    }
    /* Now TLS specifies pad length which varies from pkcs7
       but is loosely the same */
    return osz - ob[osz - 1] - 1;
}

/*!
  \brief  : aes-128-cbc encrypt input text
  \param 1: [IN] iv, initialization vector 16 bytes allocated
                 by caller on stack or heap
  \param 2: [IN] key, encryption key 16 bytes allocated by
                 caller on stack or heap
  \param 3: [IN] plaintext, can point to the same as param 5
  \param 4: [IN] length of plaintext in param 3
  \param 5: [OUT] out, if param 3 == param 5 param 3 should
                  be considered [INOUT]
  \param 6: [IN] size allocated by caller for output, param 5
                 if param 6 is 0, it is assumed that caller has
                 sufficient space for output
*/
SHORT aes_cbc_encrypt(BYTE* iv  , BYTE* key,
                      BYTE* pl  , SHORT psz,
                      BYTE* out , SHORT osz)
{
    BYTE mkey[CIPH_KEY_SZ];
    BYTE numBlocks = (psz >> 4) + 1;
    osz = ( ((psz >> 4) + 1) << 4 );
    BYTE numPad = (numBlocks << 4) - psz;
    numPad = (numPad)? numPad : 0x10;
    aes_expand_key( key, mkey );
    memcpy( out, pl, psz );
    memset( out + psz, (numPad -1), osz - psz );
    while( numBlocks -- )
    {
        aes_xor_block( out, iv );
        aes_encrypt(out, mkey, out);
        iv = out;
        out += CIPH_BLOCK_SZ;
    }
    return ((psz >> 4) + 1) << 4;
}
